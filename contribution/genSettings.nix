{ pkgs, clickhouseRepo }:


let templ = ''
{-
  This module is autogenerated. Edit /contribution/genSettings.nix
-}
module ClickHaskell.Protocol.Settings where

-- Internal
import ClickHaskell.Primitive

-- GHC
import Data.Binary (Get)
import Data.Binary.Get (lookAhead)
import Data.Bits
import Data.Bool (bool)
import Data.ByteString as BS (null)
import Data.ByteString.Builder (Builder)
import Data.Kind (Type)
import Data.Proxy (Proxy (..))
import GHC.TypeLits


-- * Server settings

data DbSettings = MkDbSettings [DbSetting]

addSetting
  :: forall name settType
  . KnownSetting name settType
  => settType
  -> DbSettings
  -> DbSettings
addSetting val (MkDbSettings xs) =
  let setting = toChType (symbolVal @name Proxy)
      flags = AfterRevision fIMPORTANT
      value = toSettingType val
  in MkDbSettings (MkDbSetting{..} : xs)

data DbSetting = MkDbSetting
  { setting    :: ChString 
  , flags      :: Flags `SinceRevision` DBMS_MIN_REVISION_WITH_SETTINGS_SERIALIZED_AS_STRINGS
  , value      :: SettingType
  }

instance Serializable DbSetting where
  deserialize rev = do
    setting <- deserialize @ChString rev
    flags <- deserialize @(Flags `SinceRevision` DBMS_MIN_REVISION_WITH_SETTINGS_SERIALIZED_AS_STRINGS) rev
    case lookup setting settingsMap of
      Nothing -> fail ("Unsupported setting " <> show setting)
      Just MkSettingSerializer{deserializer} -> do
        value <- deserializer rev
        pure $ MkDbSetting{..} 
  serialize rev MkDbSetting{setting, flags, value} =
    serialize rev setting
    <> serialize rev flags
    <> case lookup setting settingsMap of
      Nothing -> error "Impossible happened. Unknown setting was added to query packet"
      Just MkSettingSerializer{serializer} -> serializer rev value

instance Serializable DbSettings where
  serialize rev (MkDbSettings setts) =
    foldMap (serialize @DbSetting rev) setts
    <> serialize @ChString rev ""
  deserialize rev = do
    (MkChString setting) <- lookAhead (deserialize @ChString rev)
    if BS.null setting
      then deserialize @ChString rev *> pure (MkDbSettings [])
      else do
        sett <- deserialize @DbSetting rev
        (\(MkDbSettings setts) -> MkDbSettings (sett : setts))
          <$> deserialize @DbSettings rev

-- ** Flags

newtype Flags = MkFlags UVarInt
  deriving newtype (Serializable, Num, Eq, Bits)

-- *** Custom

fCUSTOM :: Flags
fCUSTOM = 0x02

isCustom :: Flags -> Bool
isCustom = (/= 0) . (.&. fCUSTOM)

setCustom :: Flags -> Flags
setCustom = (.|. fCUSTOM)

-- *** Important

fIMPORTANT :: Flags
fIMPORTANT = 0x01

isImportant :: Flags -> Bool
isImportant = (/= 0) . (.&. fIMPORTANT)

setImportant :: Flags -> Flags
setImportant = (.|. fIMPORTANT)

-- *** Tier

fTIER :: Flags
fTIER = 0x0c -- 0b1100 == 2 bits


class
  (Serializable settType, ToQueryPart settType)
  =>
  IsSettingType settType
  where
  toSettingType :: settType -> SettingType
  fromSettingType :: SettingType -> settType

  serializeSettingText :: ProtocolRevision -> SettingType -> Builder
  serializeSettingText rev = serialize @ChString rev . toChType . toQueryPart @settType . fromSettingType

  serializeSettingBinary :: ProtocolRevision -> SettingType -> Builder

data SettingType where
  SettingUInt64 :: UInt64 -> SettingType
  SettingString :: ChString -> SettingType
  SettingBool :: Bool -> SettingType

instance IsSettingType ChString where
  toSettingType str = SettingString str
  fromSettingType (SettingString str) = str
  fromSettingType _ = error "Impossible"
  serializeSettingBinary rev = serialize @ChString rev . fromSettingType

instance IsSettingType UInt64 where
  toSettingType uint64 = SettingUInt64 uint64
  fromSettingType (SettingUInt64 uint64) = uint64
  fromSettingType _ = error "Impossible"
  serializeSettingBinary rev = serialize @UVarInt rev . fromIntegral @UInt64 . fromSettingType

instance IsSettingType Bool where
  toSettingType boolean = SettingBool boolean
  fromSettingType (SettingBool boolean) = boolean
  fromSettingType _ = error "Impossible"
  serializeSettingBinary rev = serialize @UVarInt rev . bool 0 1 . fromSettingType


data SettingSerializer =
  MkSettingSerializer
    { deserializer :: ProtocolRevision -> Get SettingType
    , serializer   :: ProtocolRevision -> SettingType -> Builder
    }

class
  ( IsSettingType settType
  , KnownSymbol name
  )
  =>
  KnownSetting name settType | name -> settType
  where
  mkSettingSerializer :: (ChString, SettingSerializer)
  mkSettingSerializer =
    let name = toChType (symbolVal @name Proxy)
        deserializer = \rev ->
          if rev >= mkRev @DBMS_MIN_REVISION_WITH_SETTINGS_SERIALIZED_AS_STRINGS
          then fail "Deserialization of Settings serializaed as strings is unsuported"
          else toSettingType <$> deserialize @settType rev
        serializer = \rev ->
          if rev >= mkRev @DBMS_MIN_REVISION_WITH_SETTINGS_SERIALIZED_AS_STRINGS
          then serializeSettingText @settType rev
          else serializeSettingBinary @settType rev
    in (name, MkSettingSerializer {deserializer, serializer})

data Setting (a :: Symbol) (settType :: Type)
'';

in

pkgs.stdenv.mkDerivation {
  pname = "supported-settings";
  version = "1.0";

  src = clickhouseRepo;

  buildInputs = with pkgs; [ gawk coreutils bash ];

  installPhase = ''
    mkdir -p $out
    outFile=$out/Settings.hs

    cat > $outFile << EOF
    ${templ}
    EOF

    gawk -f - "$src/src/Core/Settings.cpp" >> $outFile <<'AWK'
      BEGIN {
        settings_count = 0
        inst_count = 0
      }

      match($0, /DECLARE\(\s*([A-Za-z0-9_]+)\s*,\s*([A-Za-z0-9_]+)/, m) {
        typ = m[1]; name = m[2];
        htype = "";

        if (typ == "UInt64") { htype="UInt64" }
        else if (typ == "String") { htype="ChString" }
        else if (typ == "Bool") { htype="Bool" }

        # TODO: add support
        else if ( \
            typ == "Dialect" || \
            typ == "Float32" || \
            typ == "Float64" || \
            typ == "Seconds" || \
            typ == "Milliseconds" || \
            typ == "MaxThreads" || \
            typ == "LoadBalancing" || \
            typ == "NonZeroUInt64" || \
            typ == "Float" || \
            typ == "Int64" || \
            typ == "Int32" || \
            typ == "TotalsMode" || \
            typ == "DistributedProductMode" || \
            typ == "UInt64Auto" || \
            typ == "UpdateParallelMode" || \
            typ == "Map" || \
            typ == "JoinStrictness" || \
            typ == "BoolAuto" || \
            typ == "OverflowMode" || \
            typ == "OverflowModeGroupBy" || \
            typ == "Double" || \
            typ == "JoinAlgorithm" || \
            typ == "LogsLevel" || \
            typ == "GeoToH3ArgumentOrder" || \
            typ == "LightweightDeleteMode" || \
            typ == "MySQLDataTypesSupport" || \
            typ == "AlterUpdateMode" || \
            typ == "IcebergMetadataLogLevel" || \
            typ == "QueryResultCacheNondeterministicFunctionHandling" || \
            typ == "DefaultTableEngine" || \
            typ == "LogQueriesType" || \
            typ == "DistributedDDLOutputMode" || \
            typ == "SetOperationMode" || \
            typ == "DecorrelationJoinKind" || \
            typ == "ShortCircuitFunctionEvaluation" || \
            typ == "LocalFSReadMethod" || \
            typ == "DistributedCacheLogMode" || \
            typ == "DistributedCachePoolBehaviourOnLimit" || \
            typ == "DateTimeInputFormat" || \
            typ == "SQLSecurityType" || \
            typ == "ParallelReplicasMode" || \
            typ == "Timezone" || \
            typ == "VectorSearchFilterStrategy" || \
            typ == "TransactionsWaitCSNMode" || \
            typ == "QueryResultCacheSystemTableHandling" \
            ) { next }

        else {
          printf("ERROR: unsupported type \"%s\" for setting \"%s\"\n", typ, name) > "/dev/stderr"
          exit 1
        }

        instances[inst_count++] = \
          "instance KnownSetting \"" name "\" " htype

        settings[settings_count++] = \
          "  mkSettingSerializer @\"" name "\""
      }

      END {
        for (i = 0; i < inst_count; ++i) {
          print instances[i]
        }

        print ""
        print "settingsMap :: [(ChString, SettingSerializer)]"
        print "settingsMap = ["
        for (i = 0; i < settings_count; ++i) {
          line = settings[i]
          if (i < settings_count - 1) line = line ","
          print line
        }
        print "  ]"
      }
    AWK
  '';
}
