{ pkgs, clickhouseRepo }:


let templ = ''
{-
  This module is autogenerated. Edit /contribution/genSettings.nix
-}
module ClickHaskell.Protocol.Settings where

-- Internal
import ClickHaskell.Primitive

-- GHC
import Data.Binary (Get)
import Data.Binary.Get (lookAhead)
import Data.Bits
import Data.Bool (bool)
import Data.ByteString as BS (null)
import Data.ByteString.Builder (Builder)
import Data.Int (Int64)
import Data.Kind (Type)
import Data.Proxy (Proxy (..))
import GHC.TypeLits


-- * Server settings

data DbSettings = MkDbSettings [DbSetting]

addSetting
  :: forall name settType
  . KnownSetting name settType
  => settType
  -> DbSettings
  -> DbSettings
addSetting val (MkDbSettings xs) =
  let setting = toChType (symbolVal @name Proxy)
      flags = AfterRevision fIMPORTANT
      value = toSettingType val
  in MkDbSettings (MkDbSetting{..} : xs)

data DbSetting = MkDbSetting
  { setting    :: ChString 
  , flags      :: Flags `SinceRevision` DBMS_MIN_REVISION_WITH_SETTINGS_SERIALIZED_AS_STRINGS
  , value      :: SettingType
  }

instance Serializable DbSetting where
  deserialize rev = do
    setting <- deserialize @ChString rev
    flags <- deserialize @(Flags `SinceRevision` DBMS_MIN_REVISION_WITH_SETTINGS_SERIALIZED_AS_STRINGS) rev
    case lookup setting settingsMap of
      Nothing -> fail ("Unsupported setting " <> show setting)
      Just MkSettingSerializer{deserializer} -> do
        value <- deserializer rev
        pure $ MkDbSetting{..} 
  serialize rev MkDbSetting{setting, flags, value} =
    serialize rev setting
    <> serialize rev flags
    <> case lookup setting settingsMap of
      Nothing -> error "Impossible happened. Unknown setting was added to query packet"
      Just MkSettingSerializer{serializer} -> serializer rev value

instance Serializable DbSettings where
  serialize rev (MkDbSettings setts) =
    foldMap (serialize @DbSetting rev) setts
    <> serialize @ChString rev ""
  deserialize rev = do
    setting <- lookAhead (deserialize @ChString rev)
    if BS.null (fromChType setting)
      then deserialize @ChString rev *> pure (MkDbSettings [])
      else do
        sett <- deserialize @DbSetting rev
        (\(MkDbSettings setts) -> MkDbSettings (sett : setts))
          <$> deserialize @DbSettings rev

-- ** Flags

newtype Flags = MkFlags UVarInt
  deriving newtype (Serializable, Num, Eq, Bits)

-- *** Custom

fCUSTOM :: Flags
fCUSTOM = 0x02

isCustom :: Flags -> Bool
isCustom = (/= 0) . (.&. fCUSTOM)

setCustom :: Flags -> Flags
setCustom = (.|. fCUSTOM)

-- *** Important

fIMPORTANT :: Flags
fIMPORTANT = 0x01

isImportant :: Flags -> Bool
isImportant = (/= 0) . (.&. fIMPORTANT)

setImportant :: Flags -> Flags
setImportant = (.|. fIMPORTANT)

-- *** Tier

fTIER :: Flags
fTIER = 0x0c -- 0b1100 == 2 bits


class
  (Serializable settType, ToQueryPart settType)
  =>
  IsSettingType settType
  where
  toSettingType :: settType -> SettingType
  fromSettingType :: SettingType -> settType

  serializeSettingText :: ProtocolRevision -> SettingType -> Builder
  serializeSettingText rev = serialize @ChString rev . toChType . toQueryPart @settType . fromSettingType

  serializeSettingBinary :: ProtocolRevision -> SettingType -> Builder

data SettingType where
  SettingUInt64 :: UInt64 -> SettingType
  SettingInt64 :: Int64 -> SettingType
  SettingFloat :: Float -> SettingType
  SettingDouble :: Double -> SettingType
  SettingString :: ChString -> SettingType
  SettingBool :: Bool -> SettingType

instance IsSettingType ChString where
  toSettingType str = SettingString str
  fromSettingType (SettingString str) = str
  fromSettingType _ = error "Impossible"
  serializeSettingBinary rev = serialize @ChString rev . fromSettingType

instance IsSettingType Int64 where
  toSettingType int64 = SettingInt64 int64
  fromSettingType (SettingInt64 int64) = int64
  fromSettingType _ = error "Impossible"
  serializeSettingBinary rev = serialize rev . fromIntegral @Int64 @VarInt . fromSettingType

instance IsSettingType Float where
  toSettingType float = SettingFloat float
  fromSettingType (SettingFloat float) = float
  fromSettingType _ = error "Impossible"
  serializeSettingBinary rev = serialize @ChString rev . toChType . toQueryPart . fromSettingType @Float

instance IsSettingType Double where
  toSettingType float = SettingDouble float
  fromSettingType (SettingDouble float) = float
  fromSettingType _ = error "Impossible"
  serializeSettingBinary rev = serialize @ChString rev . toChType . toQueryPart . fromSettingType @Double

instance IsSettingType UInt64 where
  toSettingType uint64 = SettingUInt64 uint64
  fromSettingType (SettingUInt64 uint64) = uint64
  fromSettingType _ = error "Impossible"
  serializeSettingBinary rev = serialize rev . fromIntegral @UInt64 @UVarInt . fromSettingType

instance IsSettingType Bool where
  toSettingType boolean = SettingBool boolean
  fromSettingType (SettingBool boolean) = boolean
  fromSettingType _ = error "Impossible"
  serializeSettingBinary rev = serialize @UVarInt rev . bool 0 1 . fromSettingType


data SettingSerializer =
  MkSettingSerializer
    { deserializer :: ProtocolRevision -> Get SettingType
    , serializer   :: ProtocolRevision -> SettingType -> Builder
    }

class
  ( IsSettingType settType
  , KnownSymbol name
  )
  =>
  KnownSetting name settType | name -> settType
  where
  mkSettingSerializer :: (ChString, SettingSerializer)
  mkSettingSerializer =
    let name = toChType (symbolVal @name Proxy)
        deserializer = \rev ->
          if rev >= mkRev @DBMS_MIN_REVISION_WITH_SETTINGS_SERIALIZED_AS_STRINGS
          then fail "Deserialization of Settings serializaed as strings is unsuported"
          else toSettingType <$> deserialize @settType rev
        serializer = \rev ->
          if rev >= mkRev @DBMS_MIN_REVISION_WITH_SETTINGS_SERIALIZED_AS_STRINGS
          then serializeSettingText @settType rev
          else serializeSettingBinary @settType rev
    in (name, MkSettingSerializer {deserializer, serializer})

data Setting (a :: Symbol) (settType :: Type)
'';

in

pkgs.stdenv.mkDerivation {
  pname = "supported-settings";
  version = "1.0";

  src = clickhouseRepo;

  buildInputs = with pkgs; [ gawk coreutils bash ];

  installPhase = ''
    mkdir -p $out
    outFile=$out/Settings.hs

    cat > $outFile << 'EOF'
    ${templ}
    EOF

    gawk -f - "$src/src/Core/Settings.cpp" >> $outFile <<'AWK'
      BEGIN {
        settings_count = 0
        inst_count = 0
      }

      match($0, /DECLARE\(\s*([A-Za-z0-9_]+)\s*,\s*([A-Za-z0-9_]+)/, m) {
        typ = m[1]; name = m[2];
        htype = "";

        if (typ == "UInt64") { htype="UInt64" }
        else if (typ == "String") { htype="ChString" }
        else if (typ == "Bool") { htype="Bool" }
        else if (typ == "Int64") { htype="Int64" }
        else if (typ == "Float") { htype="Float" }
        else if (typ == "Double") { htype="Double" }

        # TODO: add support
        else if ( \
            typ == "Dialect" || \
            typ == "Float32" || \
            typ == "Float64" || \
            typ == "Seconds" || \
            typ == "Milliseconds" || \
            typ == "MaxThreads" || \
            typ == "LoadBalancing" || \
            typ == "NonZeroUInt64" || \
            typ == "ArrowFlightDescriptorType" || \
            typ == "AggregateFunctionInputFormat" || \
            typ == "ObjectStorageGranularityLevel" || \
            typ == "JoinOrderAlgorithm" || \
            typ == "DeduplicateInsertSelectMode" || \
            typ == "Int32" || \
            typ == "TotalsMode" || \
            typ == "DistributedProductMode" || \
            typ == "UInt64Auto" || \
            typ == "UpdateParallelMode" || \
            typ == "Map" || \
            typ == "JoinStrictness" || \
            typ == "BoolAuto" || \
            typ == "OverflowMode" || \
            typ == "OverflowModeGroupBy" || \
            typ == "JoinAlgorithm" || \
            typ == "LogsLevel" || \
            typ == "GeoToH3ArgumentOrder" || \
            typ == "LightweightDeleteMode" || \
            typ == "MySQLDataTypesSupport" || \
            typ == "AlterUpdateMode" || \
            typ == "IcebergMetadataLogLevel" || \
            typ == "QueryResultCacheNondeterministicFunctionHandling" || \
            typ == "DefaultTableEngine" || \
            typ == "LogQueriesType" || \
            typ == "DistributedDDLOutputMode" || \
            typ == "SetOperationMode" || \
            typ == "DecorrelationJoinKind" || \
            typ == "ShortCircuitFunctionEvaluation" || \
            typ == "LocalFSReadMethod" || \
            typ == "DistributedCacheLogMode" || \
            typ == "DistributedCachePoolBehaviourOnLimit" || \
            typ == "DateTimeInputFormat" || \
            typ == "SQLSecurityType" || \
            typ == "ParallelReplicasMode" || \
            typ == "Timezone" || \
            typ == "VectorSearchFilterStrategy" || \
            typ == "TransactionsWaitCSNMode" || \
            typ == "QueryResultCacheSystemTableHandling" \
            ) { next }

        else {
          printf("ERROR: unsupported type \"%s\" for setting \"%s\"\n", typ, name) > "/dev/stderr"
          exit 1
        }

        instances[inst_count++] = \
          "instance KnownSetting \"" name "\" " htype

        settings[settings_count++] = \
          "  mkSettingSerializer @\"" name "\""
      }

      END {
        for (i = 0; i < inst_count; ++i) {
          print instances[i]
        }

        print ""
        print "settingsMap :: [(ChString, SettingSerializer)]"
        print "settingsMap = ["
        for (i = 0; i < settings_count; ++i) {
          line = settings[i]
          if (i < settings_count - 1) line = line ","
          print line
        }
        print "  ]"
      }
    AWK
  '';
}
